import { ConditionalSimplifyDeep, ExclusiveKeys, SendEventPayload, Simplify, WithoutInternal } from "../helpers/types.cjs";
import { StepFetch } from "./Fetch.cjs";
import { InngestMiddleware } from "./InngestMiddleware.cjs";
import { Jsonify } from "../helpers/jsonify.cjs";
import { DurationLike, InstantLike, ZonedDateTimeLike } from "../helpers/temporal.cjs";
import { InngestFunction } from "./InngestFunction.cjs";
import { BaseContext, ClientOptions, EventPayload, IncomingOp, InvocationResult, InvokeTargetFunctionDefinition, SendEventOutput, StepOptionsOrId, TriggerEventFromFunction, TriggersFromClient } from "../types.cjs";
import { GetFunctionOutput, Inngest } from "./Inngest.cjs";
import * as _inngest_ai0 from "@inngest/ai";

//#region src/components/InngestMetadata.d.ts
/**
 * The level at which to attach the metadata.
 */
type MetadataScope = "run" | "step" | "step_attempt" | "extended_trace";
/**
 * Metadata of the same kind attached to the same item at the same scope are combined.
 */
type MetadataKind = "inngest.warning" | `userland.${string}`;
/**
 * The operation use to combine multiple metadata updates of the same kind.
 */
type MetadataOpcode = "merge";
/**
 * A metadata update containing `values` to be merged according to `op`
 * at the configured `scope` for the configured `kind`.
 */
type MetadataUpdate = {
  kind: MetadataKind;
  scope: MetadataScope;
  op: MetadataOpcode;
  values: MetadataValues;
};
type MetadataValues = Record<string, unknown>;
/**
 * Configures and sends metadata updates.
 *
 * This is used to limit the available methods as target is
 * configured and the specified scope narrows.
 */
type MetadataBuilder<Extras = {}> = Simplify<{
  /**
   * Sets the metadata context to a specific (or current if omitted) run.
   */
  run(id?: string): Simplify<Omit<MetadataBuilder<Extras>, "run">>;
  /**
   * Sets the metadata context to a specific (or current if omitted) step.
   */
  step(id?: string, index?: number): Simplify<Omit<MetadataBuilder<Extras>, "run" | "step">>;
  /**
   * Sets the metadata context to a specific (or current if omitted) step attempt.
   */
  attempt(index?: number): Simplify<Omit<MetadataBuilder<Extras>, "run" | "step" | "attempt">>;
  /**
   * Sets the metadata context to a specific span.
   */
  span(id: string): Simplify<Omit<MetadataBuilder<Extras>, "run" | "step" | "attempt" | "span">>;
  /**
   * Attach metadata to the configured run/step/step attempt/span.
   *
   * By default it will attach metadata to the current run if
   * executed inside the body of `createFunction` or to the
   * current step attempt if executed inside `step.run`.
   */
  update(values: Record<string, unknown>, kind?: string): Promise<void>;
} & Extras>;
/**
 * A wrapper around `MetadataBuilder` to attach metadata as a step.
 */
type MetadataStepTool = MetadataBuilder<{
  /**
   * Allows many `updates` to be sent with the same scope.
   */
  do: (fn: (builder: MetadataBuilder) => Promise<void>) => Promise<void>;
}>;
/**
 * Middleware that enables the experimental step.metadata() feature.
 *
 * @example
 * ```ts
 * import { metadataMiddleware } from "inngest/experimental";
 *
 * const inngest = new Inngest({
 *   id: "my-app",
 *   middleware: [metadataMiddleware()],
 * });
 * ```
 */
declare const metadataMiddleware: () => InngestMiddleware<{
  name: string;
  init({
    client
  }: {
    client: Inngest.Any;
    fn?: InngestFunction.Any;
  }): {
    onFunctionRun(): {
      transformInput(input: Readonly<{
        ctx: Record<string, unknown> & Readonly<BaseContext<Inngest.Any, TriggersFromClient<Inngest.Any>>>;
        steps: Readonly<IncomingOp>[];
        fn: InngestFunction.Any;
        reqArgs: Readonly<unknown[]>;
      }>): {
        ctx: {
          step: {
            /**
             * Create a durable metadata update wrapped in a step
             *
             * @param memoizationId - The step ID used for the step itself, ensuring the
             *   metadata update is only performed once even on function retries.
             *
             * @example
             * ```ts
             * // Update metadata for the current run
             * await step.metadata("update-status").update({ status: "processing" });
             *
             * // Update metadata for a different run
             * await step.metadata("notify-parent")
             *   .run(parentRunId)
             *   .update({ childCompleted: true });
             * ```
             */
            metadata: (memoizationId: string) => MetadataStepTool;
            sendEvent: <Payload extends SendEventPayload<WithoutInternal<Record<string, EventPayload<any>>>>>(idOrOptions: StepOptionsOrId, payload: Payload) => Promise<SendEventOutput<ClientOptions>>;
            waitForSignal: <TData>(idOrOptions: StepOptionsOrId, opts: {
              signal: string;
              timeout: number | string | Date;
              onConflict: "replace" | "fail";
            }) => Promise<{
              signal: string;
              data: Jsonify<TData>;
            } | null>;
            sendSignal: (idOrOptions: StepOptionsOrId, opts: {
              signal: string;
              data?: unknown;
            }) => Promise<null>;
            waitForEvent: <IncomingEvent extends string>(idOrOptions: StepOptionsOrId, opts: {
              event: IncomingEvent;
              timeout: number | string | Date;
            } & ExclusiveKeys<{
              match?: string;
              if?: string;
            }, "match", "if">) => Promise<IncomingEvent extends string ? EventPayload<any> | null : IncomingEvent | null>;
            run: <TFn extends (...args: any[]) => unknown>(idOrOptions: StepOptionsOrId, fn: TFn, ...input: Parameters<TFn>) => Promise<ConditionalSimplifyDeep<Jsonify<TFn extends ((...args: Parameters<TFn>) => Promise<infer U>) ? Awaited<U extends void ? null : U> : ReturnType<TFn> extends void ? null : ReturnType<TFn>>, Function | Iterable<unknown>, object>>;
            ai: {
              infer: <TAdapter extends _inngest_ai0.AiAdapter>(idOrOptions: StepOptionsOrId, options: {
                model: TAdapter;
                body: _inngest_ai0.AiAdapter.Input<TAdapter>;
              }) => Promise<_inngest_ai0.AiAdapter.Output<TAdapter>>;
              wrap: <TFn extends (...args: any[]) => unknown>(idOrOptions: StepOptionsOrId, fn: TFn, ...input: Parameters<TFn>) => Promise<ConditionalSimplifyDeep<Jsonify<TFn extends ((...args: Parameters<TFn>) => Promise<infer U>) ? Awaited<U extends void ? null : U> : ReturnType<TFn> extends void ? null : ReturnType<TFn>>, Function | Iterable<unknown>, object>>;
              models: {
                anthropic: _inngest_ai0.AiAdapter.ModelCreator<[options: _inngest_ai0.Anthropic.AiModelOptions], _inngest_ai0.Anthropic.AiModel>;
                gemini: _inngest_ai0.AiAdapter.ModelCreator<[options: _inngest_ai0.Gemini.AiModelOptions], _inngest_ai0.Gemini.AiModel>;
                openai: _inngest_ai0.AiAdapter.ModelCreator<[options: _inngest_ai0.OpenAi.AiModelOptions], _inngest_ai0.OpenAi.AiModel>;
                deepseek: _inngest_ai0.AiAdapter.ModelCreator<[options: _inngest_ai0.DeepSeek.AiModelOptions], _inngest_ai0.DeepSeek.AiModel>;
                grok: _inngest_ai0.AiAdapter.ModelCreator<[options: _inngest_ai0.Grok.AiModelOptions], _inngest_ai0.Grok.AiModel>;
              };
            };
            sleep: (idOrOptions: StepOptionsOrId, time: number | string | DurationLike) => Promise<void>;
            sleepUntil: (idOrOptions: StepOptionsOrId, time: Date | string | InstantLike | ZonedDateTimeLike) => Promise<void>;
            invoke: <TFunction extends InvokeTargetFunctionDefinition>(idOrOptions: StepOptionsOrId, opts: {
              function: TFunction;
            } & Omit<TriggerEventFromFunction<TFunction>, "id"> & {
              timeout?: number | string | Date;
            }) => InvocationResult<GetFunctionOutput<TFunction>>;
            fetch: StepFetch;
          };
        };
      };
    };
  };
}>;
//#endregion
export { MetadataBuilder, MetadataKind, MetadataOpcode, MetadataScope, MetadataUpdate, metadataMiddleware };
//# sourceMappingURL=InngestMetadata.d.cts.map