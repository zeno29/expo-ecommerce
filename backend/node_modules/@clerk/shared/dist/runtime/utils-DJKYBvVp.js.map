{"version":3,"file":"utils-DJKYBvVp.js","names":["isDevelopmentEnvironment"],"sources":["../../src/utils/allSettled.ts","../../src/utils/logErrorInDevMode.ts","../../src/utils/fastDeepMerge.ts"],"sourcesContent":["/**\n * A ES6 compatible utility that implements `Promise.allSettled`\n * @internal\n */\nexport function allSettled<T>(\n  iterable: Iterable<Promise<T>>,\n): Promise<({ status: 'fulfilled'; value: T } | { status: 'rejected'; reason: any })[]> {\n  const promises = Array.from(iterable).map(p =>\n    p.then(\n      value => ({ status: 'fulfilled', value }) as const,\n      reason => ({ status: 'rejected', reason }) as const,\n    ),\n  );\n  return Promise.all(promises);\n}\n","import { isDevelopmentEnvironment } from './runtimeEnvironment';\n\nexport const logErrorInDevMode = (message: string) => {\n  if (isDevelopmentEnvironment()) {\n    console.error(`Clerk: ${message}`);\n  }\n};\n","// Keys that could lead to prototype pollution attacks\nconst DANGEROUS_KEYS = new Set(['__proto__', 'constructor', 'prototype']);\n\n/**\n * Merges 2 objects without creating new object references\n * The merged props will appear on the `target` object\n * If `target` already has a value for a given key it will not be overwritten\n */\nexport const fastDeepMergeAndReplace = (\n  source: Record<any, any> | undefined | null,\n  target: Record<any, any> | undefined | null,\n) => {\n  if (!source || !target) {\n    return;\n  }\n\n  for (const key in source) {\n    // Skip dangerous keys to prevent prototype pollution\n    if (DANGEROUS_KEYS.has(key)) {\n      continue;\n    }\n    if (Object.prototype.hasOwnProperty.call(source, key) && source[key] !== null && typeof source[key] === `object`) {\n      if (target[key] === undefined) {\n        target[key] = new (Object.getPrototypeOf(source[key]).constructor)();\n      }\n      fastDeepMergeAndReplace(source[key], target[key]);\n    } else if (Object.prototype.hasOwnProperty.call(source, key) && source[key] !== undefined) {\n      target[key] = source[key];\n    }\n  }\n};\n\nexport const fastDeepMergeAndKeep = (\n  source: Record<any, any> | undefined | null,\n  target: Record<any, any> | undefined | null,\n) => {\n  if (!source || !target) {\n    return;\n  }\n\n  for (const key in source) {\n    // Skip dangerous keys to prevent prototype pollution\n    if (DANGEROUS_KEYS.has(key)) {\n      continue;\n    }\n    if (Object.prototype.hasOwnProperty.call(source, key) && source[key] !== null && typeof source[key] === `object`) {\n      if (target[key] === undefined) {\n        target[key] = new (Object.getPrototypeOf(source[key]).constructor)();\n      }\n      fastDeepMergeAndKeep(source[key], target[key]);\n    } else if (Object.prototype.hasOwnProperty.call(source, key) && target[key] === undefined) {\n      target[key] = source[key];\n    }\n  }\n};\n"],"mappings":";;;;;;;AAIA,SAAgB,WACd,UACsF;CACtF,MAAM,WAAW,MAAM,KAAK,SAAS,CAAC,KAAI,MACxC,EAAE,MACA,WAAU;EAAE,QAAQ;EAAa;EAAO,IACxC,YAAW;EAAE,QAAQ;EAAY;EAAQ,EAC1C,CACF;AACD,QAAO,QAAQ,IAAI,SAAS;;;;;ACX9B,MAAa,qBAAqB,YAAoB;AACpD,KAAIA,qDAA0B,CAC5B,SAAQ,MAAM,UAAU,UAAU;;;;;ACHtC,MAAM,iBAAiB,IAAI,IAAI;CAAC;CAAa;CAAe;CAAY,CAAC;;;;;;AAOzE,MAAa,2BACX,QACA,WACG;AACH,KAAI,CAAC,UAAU,CAAC,OACd;AAGF,MAAK,MAAM,OAAO,QAAQ;AAExB,MAAI,eAAe,IAAI,IAAI,CACzB;AAEF,MAAI,OAAO,UAAU,eAAe,KAAK,QAAQ,IAAI,IAAI,OAAO,SAAS,QAAQ,OAAO,OAAO,SAAS,UAAU;AAChH,OAAI,OAAO,SAAS,OAClB,QAAO,OAAO,KAAK,OAAO,eAAe,OAAO,KAAK,EAAC,aAAc;AAEtE,2BAAwB,OAAO,MAAM,OAAO,KAAK;aACxC,OAAO,UAAU,eAAe,KAAK,QAAQ,IAAI,IAAI,OAAO,SAAS,OAC9E,QAAO,OAAO,OAAO;;;AAK3B,MAAa,wBACX,QACA,WACG;AACH,KAAI,CAAC,UAAU,CAAC,OACd;AAGF,MAAK,MAAM,OAAO,QAAQ;AAExB,MAAI,eAAe,IAAI,IAAI,CACzB;AAEF,MAAI,OAAO,UAAU,eAAe,KAAK,QAAQ,IAAI,IAAI,OAAO,SAAS,QAAQ,OAAO,OAAO,SAAS,UAAU;AAChH,OAAI,OAAO,SAAS,OAClB,QAAO,OAAO,KAAK,OAAO,eAAe,OAAO,KAAK,EAAC,aAAc;AAEtE,wBAAqB,OAAO,MAAM,OAAO,KAAK;aACrC,OAAO,UAAU,eAAe,KAAK,QAAQ,IAAI,IAAI,OAAO,SAAS,OAC9E,QAAO,OAAO,OAAO"}